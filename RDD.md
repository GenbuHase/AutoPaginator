# AutoPaginator - 要件定義書

## 1. 概要

複数ページにわたるWebページを1枚に自動で連結し、スクロールだけで閲覧可能にするページ読み込み支援拡張機能

## 2. 機能要件

- Web記事や検索結果など、複数ページにわたるWebページを1枚に連結する
- 連結したページはスクロールで閲覧できるようにする
- 連結したページは、元のページのURLを維持する

### 2.1. ページ自動結合機能

- 次ページ検出: 現在のページから「次へ」ボタンやページネーションのリンクを自動的に特定する(XPathやCSSセレクタを利用)。
- コンテンツ抽出: 次ページのメインコンテンツ部分(記事本文やリスト部分)のみを抽出し、現在のページの末尾に挿入する。
- 自動読み込みトリガー: ユーザーがページ最下部から一定距離(例：300px)までスクロールした際に、非同期(fetch/XMLHttpRequest)で次ページを取得する。

### 2.2. ステート管理・URL同期

- URL更新: スクロール位置に応じて、現在表示されているセクションに対応するURLへブラウザのアドレスバーを更新する(history.replaceState)。
- 履歴保持: 結合された各ページの表示状態を履歴に保持し、ブラウザの「戻る」操作が直感的に動くように制御する。

### 2.3. ユーザーインターフェース (UI)

- インジケーター表示: 次ページの読み込み中に、ページ下部にローディングアニメーションを表示する。

- 拡張機能ポップアップ:
  - 機能をオン/オフするトグルスイッチ。
  - 特定のドメインでのみ無効化する「ブラックリスト」設定。

- 手動トリガー: 自動検出に失敗した場合や意図的に止めたい場合のため、クリックで次ページを読み込めるようにする。

### 2.4. 設定・カスタマイズ

- サイト別設定(SITEINFO): 汎用的な自動検出が効かないサイト向けに、特定のCSSセレクタを指定できる設定機能(JSON形式でのインポート/エクスポート対応)。

## 3. 非機能要件

- パフォーマンス: ページ結合によるDOMの肥大化を考慮し、メモリ消費を抑える設計とする。
- 互換性: 最新のManifest V3に準拠し、主要なニュースサイト、Google検索、ブログプラットフォームで動作確認を行う。
- プライバシー: ユーザーの閲覧履歴を外部サーバーに送信せず、すべての処理をローカル(拡張機能内)で完結させる。
- 無限ループ防止: 「次へ」ボタンが自分自身を指しているようなループ構造のサイトで、無限に読み込みが発生しないようにするガード処理。
- 遅延読み込み（Lazy Load）への対応: 結合先のページ内に画像などのLazy Loadがある場合、挿入後に正しく発火させるためのイベント制御。
- 広告・スクリプトの重複排除: 次ページに含まれるサイドバーや広告、重複するJSコードを排除して、メインコンテンツのみを綺麗に繋げるロジック。

## 4. システム要件

### 4.1. ブラウザ

- Chrome、Edge、Firefox、Opera

### 4.2. OS

- Windows、macOS、Linux

## 5. 技術スタック

| カテゴリ | 選定技術 | 理由 |
| --- | --- | --- |
| 言語 | TypeScript | 複雑なDOM操作やメッセージ通信における型安全性の確保。 |
| ビルドツール | Vite + @crxjs/vite-plugin | 開発中のホットリロード(HMR)が強力で、拡張機能開発のストレスが激減します。 |
| マニフェスト | Manifest V3 | 現在のChrome拡張機能の標準規格。Service Workerの活用が鍵。 |
| UIライブラリ | Vue.js | ポップアップや設定画面の作成用。 |
| CSS | Tailwind CSS | 拡張機能内のUIを迅速に構築でき、CSSの干渉を防ぎやすい(Shadow DOM活用時)。 |
| 通信 | Fetch API | 次ページのHTMLを取得するため。 |
| パーサー | DOMParser | 取得した文字列(HTML)をDOMオブジェクトに変換し、必要な要素を抽出するため。 |